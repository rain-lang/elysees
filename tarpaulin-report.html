<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","arc.rs"],"content":"use crate::{abort, ArcBorrow, ArcBox};\nuse alloc::alloc::{alloc, dealloc, Layout};\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\nuse core::convert::From;\nuse core::fmt;\nuse core::hash::{Hash, Hasher};\nuse core::marker::PhantomData;\nuse core::mem;\nuse core::ops::Deref;\nuse core::ptr;\nuse core::sync::atomic;\nuse core::sync::atomic::Ordering::{self as LoadOrdering, Acquire, Relaxed, Release};\nuse core::{isize, usize};\n#[cfg(feature = \"erasable\")]\nuse erasable::{Erasable, ErasablePtr, ErasedPtr};\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Serialize};\n#[cfg(feature = \"slice-dst\")]\nuse slice_dst::{AllocSliceDst, SliceDst, TryAllocSliceDst};\n#[cfg(feature = \"stable_deref_trait\")]\nuse stable_deref_trait::{CloneStableDeref, StableDeref};\n\n/// A soft limit on the amount of references that may be made to an `Arc`.\n///\n/// Going above this limit will abort your program (although not\n/// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\nconst MAX_REFCOUNT: usize = (isize::MAX) as usize;\n\n/// The object allocated by an Arc\u003cT\u003e\n#[repr(C)]\npub struct ArcInner\u003cT: ?Sized\u003e {\n    pub(crate) count: atomic::AtomicUsize,\n    pub(crate) data: T,\n}\n\nimpl\u003cT: ?Sized\u003e ArcInner\u003cT\u003e {\n    /// Get the theoretical offset of a piece of data in an `ArcInner`, as well as the layout of that `ArcInner`\n    #[inline]\n    pub fn data_offset(data: \u0026T) -\u003e (Layout, usize) {\n        let atomic_layout = Layout::new::\u003catomic::AtomicUsize\u003e();\n        atomic_layout\n            .extend(Layout::for_value(data))\n            .unwrap_or_else(|_| abort())\n    }\n    /// Get an untyped pointer to the inner data from a data pointer, along with a layout\n    #[inline]\n    pub(crate) unsafe fn inner_ptr\u003c'a\u003e(ptr: *const T) -\u003e (Layout, *const u8) {\n        let (layout, data_offset) = ArcInner::data_offset(\u0026*ptr);\n        (layout, (ptr as *const u8).sub(data_offset))\n    }\n    /// Get an untyped mutable pointer to the inner data from a data pointer, along with a layout\n    #[inline]\n    pub(crate) unsafe fn inner_ptr_mut\u003c'a\u003e(ptr: *mut T) -\u003e (Layout, *mut u8) {\n        let (layout, data_offset) = ArcInner::data_offset(\u0026*ptr);\n        (layout, (ptr as *mut u8).sub(data_offset))\n    }\n    /// Get a reference to the reference count from a data pointer\n    #[inline]\n    pub(crate) unsafe fn refcount_ptr\u003c'a\u003e(ptr: *const T) -\u003e \u0026'a atomic::AtomicUsize {\n        \u0026*(ArcInner::inner_ptr(ptr).1 as *const atomic::AtomicUsize)\n    }\n}\n\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Send for ArcInner\u003cT\u003e {}\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Sync for ArcInner\u003cT\u003e {}\n\n/// An atomically reference counted shared pointer\n///\n/// See the documentation for [`Arc`] in the standard library.\n/// Unlike the standard library `Arc`, this `Arc` holds a pointer to the `T` instead of to the entire `ArcInner`.\n/// This makes the struct FFI-compatible, and allows a variety of pointer casts, e.g. `\u0026[Arc\u003cT\u003e]` to `\u0026[\u0026T]`.\n///\n/// ```text\n///   std::sync::Arc\u003cT\u003e     elysees::Arc\u003cT\u003e\n///   |                     |\n///   v                     v\n///  --------------------------------------\n/// | RefCount            | T (data)       | [ArcInner\u003cT\u003e]\n///  --------------------------------------\n/// ```\n///\n/// This means that this is a direct pointer to its contained data (and can be read from by both C/C++ and Rust)\n///\n/// This is very useful if you have an Arc-containing struct shared between Rust and C/C++,\n/// and wish for C/C++ to be able to read the data behind the `Arc` without incurring\n/// an FFI call overhead. This also enables a variety of useful casts, which are provided as safe functions by\n/// the library, e.g. \u0026Arc\u003cT\u003e -\u003e \u0026*const T, which can help with safe implementation of complex `ByAddress`\n/// datastructures\n///\n/// [`Arc`]: https://doc.rust-lang.org/stable/std/sync/struct.Arc.html\n#[repr(transparent)]\npub struct Arc\u003cT: ?Sized\u003e {\n    pub(crate) ptr: ptr::NonNull\u003cT\u003e,\n    pub(crate) phantom: PhantomData\u003cT\u003e,\n}\n\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Send for Arc\u003cT\u003e {}\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Sync for Arc\u003cT\u003e {}\n\nimpl\u003cT\u003e Arc\u003cT\u003e {\n    /// Construct an `Arc\u003cT\u003e`\n    #[inline]\n    pub fn new(data: T) -\u003e Self {\n        let inner = ArcInner {\n            count: atomic::AtomicUsize::new(1),\n            data,\n        };\n        let layout = Layout::for_value(\u0026inner);\n        let alloc_ref = unsafe {\n            let allocation = alloc(layout) as *mut ArcInner\u003cT\u003e;\n            ptr::write(allocation, inner);\n            \u0026*allocation\n        };\n        Arc {\n            ptr: (\u0026alloc_ref.data).into(),\n            phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Arc\u003cT\u003e {\n    /// Borrow this `Arc\u003cT\u003e` as an `ArcBorrow\u003cT\u003e`\n    #[inline]\n    pub fn borrow_arc(\u0026self) -\u003e ArcBorrow\u003cT\u003e {\n        unsafe { ArcBorrow::from_ref(self.deref()) }\n    }\n    /// Leak this `Arc\u003cT\u003e`, getting an `ArcBorrow\u003c'static, T\u003e`\n    ///\n    /// You can call the `get` method on the returned `ArcBorrow` to get an `\u0026'static T`.\n    /// Note that using this can (obviously) cause memory leaks!\n    #[inline]\n    pub fn leak(this: Arc\u003cT\u003e) -\u003e ArcBorrow\u003c'static, T\u003e {\n        let result = unsafe { ArcBorrow::from_ref(\u0026*this.ptr.as_ptr()) };\n        mem::forget(this);\n        result\n    }\n    /// Convert the `Arc\u003cT\u003e` to a raw pointer, suitable for use across FFI\n    ///\n    /// Note: This returns a pointer to the data T, which is offset in the allocation.\n    #[inline]\n    pub fn into_raw(this: Self) -\u003e *const T {\n        let ptr = this.ptr;\n        mem::forget(this);\n        ptr.as_ptr()\n    }\n    /// Get the raw pointer underlying this `Arc\u003cT\u003e`\n    #[inline]\n    pub fn as_ptr(this: \u0026Arc\u003cT\u003e) -\u003e *const T {\n        this.ptr.as_ptr()\n    }\n    /// Convert the `Arc\u003cT\u003e` from a raw pointer obtained from `into_raw()`\n    ///\n    /// Note: This raw pointer will be offset in the allocation and must be preceded\n    /// by the atomic count.\n    #[inline]\n    pub unsafe fn from_raw(ptr: *const T) -\u003e Arc\u003cT\u003e {\n        Arc {\n            ptr: ptr::NonNull::new_unchecked(ptr as *mut T),\n            phantom: PhantomData,\n        }\n    }\n    // Non-inlined part of `drop`. Just invokes the destructor.\n    #[inline(never)]\n    unsafe fn drop_slow(\u0026mut self) {\n        // Step 1: drop data\n        ptr::drop_in_place(self.ptr.as_ptr());\n        // Step 2: free Inner\n        let (layout, data) = ArcInner::inner_ptr_mut(self.ptr.as_ptr());\n        dealloc(data, layout)\n    }\n    /// Get a reference to the reference count of this `Arc`\n    #[inline]\n    fn borrow_refcount(\u0026self) -\u003e \u0026atomic::AtomicUsize {\n        unsafe { ArcInner::refcount_ptr(self.ptr.as_ptr()) }\n    }\n    /// Whether or not the `Arc` is uniquely owned (is the refcount 1?).\n    #[inline]\n    pub fn is_unique(\u0026self) -\u003e bool {\n        // See the extensive discussion in [1] for why this needs to be Acquire.\n        //\n        // [1] https://github.com/servo/servo/issues/21186\n        Arc::count(self, Acquire) == 1\n    }\n    /// Try to convert this `Arc` to an `ArcBox` if it is unique\n    #[inline]\n    pub fn try_unique(self) -\u003e Result\u003cArcBox\u003cT\u003e, Arc\u003cT\u003e\u003e {\n        if self.is_unique() {\n            Ok(ArcBox(self))\n        } else {\n            Err(self)\n        }\n    }\n    /// Get the reference count of this `Arc` with a given ordering\n    #[inline]\n    pub fn count(this: \u0026Arc\u003cT\u003e, ordering: LoadOrdering) -\u003e usize {\n        this.borrow_refcount().load(ordering)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Drop for Arc\u003cT\u003e {\n    #[inline]\n    fn drop(\u0026mut self) {\n        // Because `fetch_sub` is already atomic, we do not need to synchronize\n        // with other threads unless we are going to delete the object.\n        if self.borrow_refcount().fetch_sub(1, Release) != 1 {\n            return;\n        }\n\n        // FIXME(bholley): Use the updated comment when [2] is merged.\n        //\n        // This load is needed to prevent reordering of use of the data and\n        // deletion of the data.  Because it is marked `Release`, the decreasing\n        // of the reference count synchronizes with this `Acquire` load. This\n        // means that use of the data happens before decreasing the reference\n        // count, which happens before this load, which happens before the\n        // deletion of the data.\n        //\n        // As explained in the [Boost documentation][1],\n        //\n        // \u003e It is important to enforce any possible access to the object in one\n        // \u003e thread (through an existing reference) to *happen before* deleting\n        // \u003e the object in a different thread. This is achieved by a \"release\"\n        // \u003e operation after dropping a reference (any access to the object\n        // \u003e through this reference must obviously happened before), and an\n        // \u003e \"acquire\" operation before deleting the object.\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        // [2]: https://github.com/rust-lang/rust/pull/41714\n        self.borrow_refcount().load(Acquire);\n\n        unsafe {\n            self.drop_slow();\n        }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Clone for Arc\u003cT\u003e {\n    #[inline]\n    fn clone(\u0026self) -\u003e Self {\n        // Using a relaxed ordering is alright here, as knowledge of the\n        // original reference prevents other threads from erroneously deleting\n        // the object.\n        //\n        // As explained in the [Boost documentation][1], Increasing the\n        // reference counter can always be done with memory_order_relaxed: New\n        // references to an object can only be formed from an existing\n        // reference, and passing an existing reference from one thread to\n        // another must already provide any required synchronization.\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        let old_size = self.borrow_refcount().fetch_add(1, Relaxed);\n\n        // However we need to guard against massive refcounts in case someone\n        // is `mem::forget`ing Arcs. If we don't do this the count can overflow\n        // and users will use-after free. We racily saturate to `isize::MAX` on\n        // the assumption that there aren't ~2 billion threads incrementing\n        // the reference count at once. This branch will never be taken in\n        // any realistic program.\n        //\n        // We abort because such a program is incredibly degenerate, and we\n        // don't care to support it.\n        if old_size \u003e MAX_REFCOUNT {\n            abort();\n        }\n\n        Arc {\n            ptr: self.ptr,\n            phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Deref for Arc\u003cT\u003e {\n    type Target = T;\n\n    #[inline]\n    fn deref(\u0026self) -\u003e \u0026T {\n        unsafe { \u0026*self.ptr.as_ptr() }\n    }\n}\n\nimpl\u003cT: Clone\u003e Arc\u003cT\u003e {\n    /// Makes a mutable reference to the `ArcHandle`, cloning if necessary\n    ///\n    /// This is functionally equivalent to [`Arc::make_mut`][mm] from the standard library.\n    ///\n    /// If this `ArcHandle` is uniquely owned, `make_mut()` will provide a mutable\n    /// reference to the contents. If not, `make_mut()` will create a _new_ `ArcHandle`\n    /// with a copy of the contents, update `this` to point to it, and provide\n    /// a mutable reference to its contents.\n    ///\n    /// This is useful for implementing copy-on-write schemes where you wish to\n    /// avoid copying things if your `Arc` is not shared.\n    ///\n    /// [mm]: https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.make_mut\n    #[inline]\n    pub fn make_mut(this: \u0026mut Self) -\u003e \u0026mut T {\n        if !this.is_unique() {\n            // Another pointer exists; clone\n            *this = Arc::new((**this).clone());\n        }\n\n        unsafe {\n            // This unsafety is ok because we're guaranteed that the pointer\n            // returned is the *only* pointer that will ever be returned to T. Our\n            // reference count is guaranteed to be 1 at this point, and we required\n            // the Arc itself to be `mut`, so we're returning the only possible\n            // reference to the inner data.\n            \u0026mut *this.ptr.as_ptr()\n        }\n    }\n    /// Convert this `Arc` to an `ArcBox`, cloning the internal data if necessary for uniqueness\n    #[inline]\n    pub fn unique(self) -\u003e ArcBox\u003cT\u003e {\n        if self.is_unique() {\n            ArcBox(self)\n        } else {\n            ArcBox::new(self.deref().clone())\n        }\n    }\n}\n\nimpl\u003cT: ?Sized + PartialEq\u003e PartialEq for Arc\u003cT\u003e {\n    fn eq(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) == *(*other)\n    }\n\n    fn ne(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) != *(*other)\n    }\n}\n\nimpl\u003cT: ?Sized + PartialOrd\u003e PartialOrd for Arc\u003cT\u003e {\n    fn partial_cmp(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e Option\u003cOrdering\u003e {\n        (**self).partial_cmp(\u0026**other)\n    }\n\n    fn lt(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003c *(*other)\n    }\n\n    fn le(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003c= *(*other)\n    }\n\n    fn gt(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003e *(*other)\n    }\n\n    fn ge(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003e= *(*other)\n    }\n}\n\nimpl\u003cT: ?Sized + Ord\u003e Ord for Arc\u003cT\u003e {\n    fn cmp(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e Ordering {\n        (**self).cmp(\u0026**other)\n    }\n}\n\nimpl\u003cT: ?Sized + Eq\u003e Eq for Arc\u003cT\u003e {}\n\nimpl\u003cT: ?Sized + fmt::Display\u003e fmt::Display for Arc\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\u0026**self, f)\n    }\n}\n\nimpl\u003cT: ?Sized + fmt::Debug\u003e fmt::Debug for Arc\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Debug::fmt(\u0026**self, f)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e fmt::Pointer for Arc\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Pointer::fmt(\u0026Arc::as_ptr(self), f)\n    }\n}\n\nimpl\u003cT: Default\u003e Default for Arc\u003cT\u003e {\n    #[inline]\n    fn default() -\u003e Arc\u003cT\u003e {\n        Arc::new(Default::default())\n    }\n}\n\nimpl\u003cT: ?Sized + Hash\u003e Hash for Arc\u003cT\u003e {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        (**self).hash(state)\n    }\n}\n\nimpl\u003cT\u003e From\u003cT\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn from(t: T) -\u003e Self {\n        Arc::new(t)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cT\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cT\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*const T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*const T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*mut T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*mut T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cptr::NonNull\u003cT\u003e\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cptr::NonNull\u003cT\u003e\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003cT: ?Sized\u003e StableDeref for Arc\u003cT\u003e {}\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003cT: ?Sized\u003e CloneStableDeref for Arc\u003cT\u003e {}\n\n#[cfg(feature = \"serde\")]\nimpl\u003c'de, T: Deserialize\u003c'de\u003e\u003e Deserialize\u003c'de\u003e for Arc\u003cT\u003e {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cArc\u003cT\u003e, D::Error\u003e\n    where\n        D: ::serde::de::Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(Arc::new)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl\u003cT: ?Sized + Serialize\u003e Serialize for Arc\u003cT\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ::serde::ser::Serializer,\n    {\n        (**self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"erasable\")]\nunsafe impl\u003cT: ?Sized + Erasable\u003e ErasablePtr for Arc\u003cT\u003e {\n    fn erase(this: Self) -\u003e ErasedPtr {\n        let ptr = unsafe { ptr::NonNull::new_unchecked(Arc::into_raw(this) as *mut _) };\n        T::erase(ptr)\n    }\n\n    unsafe fn unerase(this: ErasedPtr) -\u003e Self {\n        Self::from_raw(T::unerase(this).as_ptr())\n    }\n}\n\n#[cfg(feature = \"slice-dst\")]\nunsafe impl\u003cS: ?Sized + SliceDst\u003e TryAllocSliceDst\u003cS\u003e for Arc\u003cS\u003e {\n    unsafe fn try_new_slice_dst\u003cI, E\u003e(len: usize, init: I) -\u003e Result\u003cSelf, E\u003e\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e) -\u003e Result\u003c(), E\u003e,\n    {\n        pub struct RawAlloc(*mut u8, Layout);\n\n        impl Drop for RawAlloc {\n            fn drop(\u0026mut self) {\n                unsafe { dealloc(self.0, self.1) }\n            }\n        }\n\n        // Compute layouts\n        let slice_layout = S::layout_for(len);\n        let count_layout = Layout::new::\u003catomic::AtomicUsize\u003e();\n        let (inner_layout, slice_offset) = count_layout\n            .extend(slice_layout)\n            .expect(\"Integer overflow computing slice layout\");\n        // Allocate\n        let inner_alloc = alloc(inner_layout);\n        let drop_guard = RawAlloc(inner_alloc, inner_layout);\n        // Write counter\n        ptr::write(\n            inner_alloc as *mut atomic::AtomicUsize,\n            atomic::AtomicUsize::new(1),\n        );\n\n        // Get slice pointer\n        let slice_addr = inner_alloc.add(slice_offset) as *mut ();\n        let slice_ptr = core::slice::from_raw_parts_mut(slice_addr, len);\n\n        // Get DST pointer\n        let ptr = S::retype(ptr::NonNull::new_unchecked(slice_ptr));\n\n        // Attempt to initialize the DST pointer\n        init(ptr)?;\n\n        // Successful construction: forget the drop guard and make an `Arc`\n        mem::forget(drop_guard);\n        Ok(Arc {\n            ptr,\n            phantom: PhantomData,\n        })\n    }\n}\n\nunsafe impl\u003cS: ?Sized + SliceDst\u003e AllocSliceDst\u003cS\u003e for Arc\u003cS\u003e {\n    unsafe fn new_slice_dst\u003cI\u003e(len: usize, init: I) -\u003e Self\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e),\n    {\n        enum Void {} // or never (!) once it is stable\n        #[allow(clippy::unit_arg)]\n        let init = |ptr| Ok::\u003c(), Void\u003e(init(ptr));\n        match Self::try_new_slice_dst(len, init) {\n            Ok(a) =\u003e a,\n            Err(void) =\u003e match void {},\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn data_offset_sanity_tests() {\n        #[allow(dead_code)]\n        struct MyStruct {\n            id: usize,\n            name: String,\n            hash: u64,\n        };\n        let inner = ArcInner {\n            count: atomic::AtomicUsize::new(1),\n            data: MyStruct {\n                id: 596843,\n                name: \"Jane\".into(),\n                hash: 0xFF45345,\n            },\n        };\n        let data = \u0026inner.data;\n        let data_ptr = data as *const _;\n        let data_addr = data_ptr as usize;\n        let inner_addr = \u0026inner as *const _ as usize;\n        let (layout, data_offset) = ArcInner::data_offset(data);\n        assert_eq!(data_addr - inner_addr, data_offset);\n        assert_eq!(layout, Layout::for_value(\u0026inner));\n    }\n}\n","traces":[{"line":40,"address":[4225408],"length":1,"stats":{"Line":3},"fn_name":"data_offset\u003celysees::arc::tests::data_offset_sanity_tests::MyStruct\u003e"},{"line":41,"address":[4225435],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[4225470],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[4225455],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[4225520,4225524,4225539],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003celysees::arc::tests::data_offset_sanity_tests::MyStruct\u003e"},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[4251918,4251840],"length":1,"stats":{"Line":1},"fn_name":"try_new_slice_dst\u003cslice_dst::provided_types::SliceWithHeader\u003c\u0026str, i32\u003e,closure-0,elysees::arc::{{impl}}::new_slice_dst::Void\u003e"},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[4216944],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":505,"address":[4216949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[4251648],"length":1,"stats":{"Line":1},"fn_name":"new_slice_dst\u003cslice_dst::provided_types::SliceWithHeader\u003c\u0026str, i32\u003e,closure-0\u003e"},{"line":550,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[4216277,4216272],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":570,"address":[4226071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[4226150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[4226278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[4226286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[4226294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":[4226310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[4226326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[4226416,4226467,4227425,4226609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[4226956,4226583,4227096],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":85,"coverable":153},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","borrow.rs"],"content":"use core::borrow::Borrow;\nuse core::convert::AsRef;\nuse core::hash::Hash;\nuse core::mem;\nuse core::ops::Deref;\nuse core::ptr;\nuse core::sync::atomic::Ordering;\n#[cfg(feature = \"erasable\")]\nuse erasable::{Erasable, ErasablePtr, ErasedPtr};\n#[cfg(feature = \"serde\")]\nuse serde::Serialize;\n#[cfg(feature = \"stable_deref_trait\")]\nuse stable_deref_trait::{CloneStableDeref, StableDeref};\n\nuse super::Arc;\n\n/// A \"borrowed `Arc`\". This is a pointer to\n/// a T that is known to have been allocated within an\n/// `Arc`.\n///\n/// This is equivalent in guarantees to `\u0026ArcHandle\u003cT\u003e`, however it is\n/// a bit more flexible. To obtain an `\u0026ArcHandle\u003cT\u003e` you must have\n/// an `ArcHandle\u003cT\u003e` instance somewhere pinned down until we're done with it.\n/// It's also a direct pointer to `T`, so using this involves less pointer-chasing\n///\n/// However, C++ code may hand us refcounted things as pointers to T directly,\n/// so we have to conjure up a temporary `Arc` on the stack each time. The\n/// same happens for when the object is managed by a `Arc`.\n///\n/// `ArcBorrow` lets us deal with borrows of known-refcounted objects\n/// without needing to worry about where the `Arc\u003cT\u003e` is.\n#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[repr(transparent)]\npub struct ArcBorrow\u003c'a, T: ?Sized + 'a\u003e(pub(crate) \u0026'a T);\n\nimpl\u003c'a, T: ?Sized\u003e Copy for ArcBorrow\u003c'a, T\u003e {}\nimpl\u003c'a, T: ?Sized\u003e Clone for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn clone(\u0026self) -\u003e Self {\n        *self\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e ArcBorrow\u003c'a, T\u003e {\n    /// Clone this as an `Arc\u003cT\u003e`. This bumps the refcount.\n    #[inline]\n    pub fn clone_arc(\u0026self) -\u003e Arc\u003cT\u003e {\n        self.as_arc().clone()\n    }\n\n    /// Borrow this as an `Arc\u003cT\u003e`. This does *not* bump the refcount.\n    #[inline]\n    pub fn as_arc(\u0026self) -\u003e \u0026Arc\u003cT\u003e {\n        unsafe { std::mem::transmute(self) }\n    }\n\n    /// For constructing from a reference known to be Arc-backed,\n    /// e.g. if we obtain such a reference over FFI\n    #[inline]\n    pub unsafe fn from_ref(r: \u0026'a T) -\u003e Self {\n        ArcBorrow(r)\n    }\n\n    /// Compare two `ArcBorrow`s via pointer equality. Will only return\n    /// true if they come from the same allocation\n    #[inline]\n    pub fn ptr_eq(this: \u0026Self, other: \u0026Self) -\u003e bool {\n        this.0 as *const T == other.0 as *const T\n    }\n\n    /// Similar to deref, but uses the lifetime |a| rather than the lifetime of\n    /// self, which is incompatible with the signature of the Deref trait.\n    #[inline]\n    pub fn get(\u0026self) -\u003e \u0026'a T {\n        self.0\n    }\n\n    /// Get the reference count of this `Arc` with a given memory ordering\n    pub fn count(this: ArcBorrow\u003c'a, T\u003e, ordering: Ordering) -\u003e usize {\n        Arc::count(this.as_arc(), ordering)\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Deref for ArcBorrow\u003c'a, T\u003e {\n    type Target = T;\n\n    #[inline]\n    fn deref(\u0026self) -\u003e \u0026T {\n        self.0\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003cArc\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn borrow(\u0026self) -\u003e \u0026Arc\u003cT\u003e {\n        self.as_arc()\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003c\u0026'a T\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn borrow(\u0026self) -\u003e \u0026\u0026'a T {\n        unsafe { std::mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003cT\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn borrow(\u0026self) -\u003e \u0026T {\n        self.deref()\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003cArc\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026Arc\u003cT\u003e {\n        self.as_arc()\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003c\u0026'a T\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026\u0026'a T {\n        unsafe { std::mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003cT\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026T {\n        self.deref()\n    }\n}\n\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003c*const T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003c*const T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003c*mut T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003c*mut T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003cptr::NonNull\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003cptr::NonNull\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003c'a, T: ?Sized\u003e StableDeref for ArcBorrow\u003c'a, T\u003e {}\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003c'a, T: ?Sized\u003e CloneStableDeref for ArcBorrow\u003c'a, T\u003e {}\n\n#[cfg(feature = \"serde\")]\nimpl\u003c'a, T: ?Sized + Serialize\u003e Serialize for ArcBorrow\u003c'a, T\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ::serde::ser::Serializer,\n    {\n        (**self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"erasable\")]\nunsafe impl\u003c'a, T: ?Sized + Erasable\u003e ErasablePtr for ArcBorrow\u003c'a, T\u003e {\n    fn erase(this: Self) -\u003e ErasedPtr {\n        T::erase(this.0.into())\n    }\n    unsafe fn unerase(this: ErasedPtr) -\u003e Self {\n        ArcBorrow(\u0026*T::unerase(this).as_ptr())\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":45},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","lib.rs"],"content":"// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 \u003cLICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0\u003e or the MIT license\n// \u003cLICENSE-MIT or http://opensource.org/licenses/MIT\u003e, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! [![crates.io](https://img.shields.io/crates/v/elysees)](https://crates.io/crates/elysees)\n//! [![Downloads](https://img.shields.io/crates/d/elysees)](https://crates.io/crates/elysees)\n//! Fork of Arc, now with more pointer tricks.\n\n#![allow(missing_docs)]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nextern crate alloc;\n#[cfg(feature = \"std\")]\nextern crate core;\n\n#[cfg(feature = \"serde\")]\nextern crate serde;\n#[cfg(feature = \"stable_deref_trait\")]\nextern crate stable_deref_trait;\n\nmod arc;\nmod borrow;\n#[cfg(feature = \"ptr-union\")]\nmod union;\nmod unique;\n\npub use arc::*;\npub use borrow::*;\npub use union::*;\npub use unique::*;\n\n#[cfg(feature = \"std\")]\nuse std::process::abort;\n\n// `no_std`-compatible abort by forcing a panic while already panicing.\n#[cfg(not(feature = \"std\"))]\n#[cold]\nfn abort() -\u003e ! {\n    struct PanicOnDrop;\n    impl Drop for PanicOnDrop {\n        fn drop(\u0026mut self) {\n            panic!()\n        }\n    }\n    let _double_panicer = PanicOnDrop;\n    panic!();\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","union.rs"],"content":"use crate::{Arc, ArcBorrow, ArcBox};\nuse erasable::ErasablePtr;\nuse erasable::Thin;\nuse ptr_union::{Builder2, Builder4, Union2, Union4};\n\n/// A value which can be made into *any* pointer union\npub unsafe trait UnionAlign: Sized + ErasablePtr {\n    fn left\u003cB: UnionAlign\u003e(this: Self) -\u003e Union2\u003cSelf, B\u003e {\n        unsafe { Builder2::new_unchecked().a(this) }\n    }\n    fn right\u003cA: UnionAlign\u003e(this: Self) -\u003e Union2\u003cA, Self\u003e {\n        unsafe { Builder2::new_unchecked().b(this) }\n    }\n    fn a\u003cB: UnionAlign, C: UnionAlign, D: UnionAlign\u003e(this: Self) -\u003e Union4\u003cSelf, B, C, D\u003e {\n        unsafe { Builder4::new_unchecked().a(this) }\n    }\n    fn b\u003cA: UnionAlign, C: UnionAlign, D: UnionAlign\u003e(this: Self) -\u003e Union4\u003cA, Self, C, D\u003e {\n        unsafe { Builder4::new_unchecked().b(this) }\n    }\n    fn c\u003cA: UnionAlign, B: UnionAlign, D: UnionAlign\u003e(this: Self) -\u003e Union4\u003cA, B, Self, D\u003e {\n        unsafe { Builder4::new_unchecked().c(this) }\n    }\n    fn d\u003cA: UnionAlign, B: UnionAlign, C: UnionAlign\u003e(this: Self) -\u003e Union4\u003cA, B, C, Self\u003e {\n        unsafe { Builder4::new_unchecked().d(this) }\n    }\n}\n\nunsafe impl\u003cT: ?Sized\u003e UnionAlign for Arc\u003cT\u003e where Arc\u003cT\u003e: ErasablePtr {}\nunsafe impl\u003cT: ?Sized\u003e UnionAlign for Thin\u003cArc\u003cT\u003e\u003e\nwhere\n    Thin\u003cArc\u003cT\u003e\u003e: ErasablePtr,\n    Arc\u003cT\u003e: ErasablePtr,\n{\n}\nunsafe impl\u003c'a, T: ?Sized\u003e UnionAlign for ArcBorrow\u003c'a, T\u003e where ArcBorrow\u003c'a, T\u003e: ErasablePtr {}\nunsafe impl\u003cT: ?Sized\u003e UnionAlign for ArcBox\u003cT\u003e where ArcBox\u003cT\u003e: ErasablePtr {}","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","unique.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\nuse core::convert::AsRef;\nuse core::hash::Hash;\nuse core::mem;\nuse core::ops::{Deref, DerefMut};\nuse core::ptr;\n#[cfg(feature = \"erasable\")]\nuse erasable::{Erasable, ErasablePtr, ErasedPtr};\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Serialize};\n#[cfg(feature = \"slice-dst\")]\nuse slice_dst::{AllocSliceDst, SliceDst, TryAllocSliceDst};\n#[cfg(feature = \"stable_deref_trait\")]\nuse stable_deref_trait::StableDeref;\n\nuse super::Arc;\n\n/// An `Arc` that is known to be uniquely owned\n///\n/// When `Arc`s are constructed, they are known to be\n/// uniquely owned. In such a case it is safe to mutate\n/// the contents of the `Arc`. Normally, one would just handle\n/// this by mutating the data on the stack before allocating the\n/// `Arc`, however it's possible the data is large or unsized\n/// and you need to heap-allocate it earlier in such a way\n/// that it can be freely converted into a regular `Arc` once you're\n/// done.\n///\n/// `ArcBox` exists for this purpose, when constructed it performs\n/// the same allocations necessary for an `Arc`, however it allows mutable access.\n/// Once the mutation is finished, you can call `.shareable()` and get a regular `Arc`\n/// out of it. You can also attempt to cast an `Arc` back into a `ArcBox`, which will\n/// succeed if the `Arc` is unique\n///\n/// ```rust\n/// # use elysees::ArcBox;\n/// # use std::ops::Deref;\n/// let data = [1, 2, 3, 4, 5];\n/// let mut x = ArcBox::new(data);\n/// let x_ptr = x.deref() as *const _;\n///\n/// x[4] = 7; // mutate!\n///\n/// // The allocation has been modified, but not moved\n/// assert_eq!(x.deref(), \u0026[1, 2, 3, 4, 7]);\n/// assert_eq!(x_ptr, x.deref() as *const _);\n///\n/// let y = x.shareable(); // y is an Arc\u003cT\u003e\n///\n/// // The allocation has not been modified or moved\n/// assert_eq!(y.deref(), \u0026[1, 2, 3, 4, 7]);\n/// assert_eq!(x_ptr, y.deref() as *const _);\n/// ```\n\n#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[repr(transparent)]\npub struct ArcBox\u003cT: ?Sized\u003e(pub(crate) Arc\u003cT\u003e);\n\nimpl\u003cT\u003e ArcBox\u003cT\u003e {\n    /// Construct a new ArcBox\n    #[inline]\n    pub fn new(data: T) -\u003e Self {\n        ArcBox(Arc::new(data))\n    }\n}\n\nimpl\u003cT: Clone\u003e Clone for ArcBox\u003cT\u003e {\n    #[inline]\n    fn clone(\u0026self) -\u003e ArcBox\u003cT\u003e {\n        ArcBox(Arc::new(self.0.deref().clone()))\n    }\n}\n\nimpl\u003cT: ?Sized\u003e ArcBox\u003cT\u003e {\n    /// Convert to a shareable Arc\u003cT\u003e once we're done mutating it\n    #[inline]\n    pub fn shareable(self) -\u003e Arc\u003cT\u003e {\n        self.0\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Deref for ArcBox\u003cT\u003e {\n    type Target = T;\n    #[inline]\n    fn deref(\u0026self) -\u003e \u0026T {\n        \u0026*self.0\n    }\n}\n\nimpl\u003cT: ?Sized\u003e DerefMut for ArcBox\u003cT\u003e {\n    #[inline]\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut T {\n        // We know this to be uniquely owned\n        unsafe { \u0026mut *self.0.ptr.as_ptr() }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e BorrowMut\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut **self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsMut\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut **self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*const T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*const T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*mut T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*mut T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cptr::NonNull\u003cT\u003e\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cptr::NonNull\u003cT\u003e\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003cT: ?Sized\u003e StableDeref for ArcBox\u003cT\u003e {}\n\n#[cfg(feature = \"serde\")]\nimpl\u003c'de, T: Deserialize\u003c'de\u003e\u003e Deserialize\u003c'de\u003e for ArcBox\u003cT\u003e {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cArcBox\u003cT\u003e, D::Error\u003e\n    where\n        D: ::serde::de::Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(ArcBox::new)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl\u003cT: ?Sized + Serialize\u003e Serialize for ArcBox\u003cT\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ::serde::ser::Serializer,\n    {\n        (**self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"erasable\")]\nunsafe impl\u003cT: ?Sized + Erasable\u003e ErasablePtr for ArcBox\u003cT\u003e {\n    fn erase(this: Self) -\u003e ErasedPtr {\n        ErasablePtr::erase(this.0)\n    }\n\n    unsafe fn unerase(this: ErasedPtr) -\u003e Self {\n        ArcBox(ErasablePtr::unerase(this))\n    }\n}\n\n#[cfg(feature = \"slice-dst\")]\nunsafe impl\u003cS: ?Sized + SliceDst\u003e TryAllocSliceDst\u003cS\u003e for ArcBox\u003cS\u003e {\n    unsafe fn try_new_slice_dst\u003cI, E\u003e(len: usize, init: I) -\u003e Result\u003cSelf, E\u003e\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e) -\u003e Result\u003c(), E\u003e,\n    {\n        Arc::try_new_slice_dst(len, init).map(ArcBox)\n    }\n}\n\nunsafe impl\u003cS: ?Sized + SliceDst\u003e AllocSliceDst\u003cS\u003e for ArcBox\u003cS\u003e {\n    unsafe fn new_slice_dst\u003cI\u003e(len: usize, init: I) -\u003e Self\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e),\n    {\n        ArcBox(Arc::new_slice_dst(len, init))\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4218000],"length":1,"stats":{"Line":1},"fn_name":"shareable\u003ci32\u003e"},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4217968],"length":1,"stats":{"Line":1},"fn_name":"deref_mut\u003ci32\u003e"},{"line":94,"address":[4217977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":38},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","tests","arc_tests.rs"],"content":"use elysees::*;\nuse std::ops::Deref;\nuse std::sync::atomic::Ordering;\n\n#[test]\nfn basic_arc_creation_works() {\n    let x = Arc::new(7);\n    assert!(x.is_unique());\n    assert_eq!(*x.deref(), 7);\n    let y = x.clone();\n    assert!(!x.is_unique());\n    assert!(!y.is_unique());\n    assert_eq!(Arc::count(\u0026x, Ordering::Relaxed), 2);\n    assert_eq!(Arc::count(\u0026y, Ordering::Relaxed), 2);\n    let x = Arc::try_unique(x).expect_err(\"x is not unique!\");\n    assert!(!x.is_unique());\n    assert!(!y.is_unique());\n    assert_eq!(x, y);\n    assert_eq!(*x.deref(), 7);\n    std::mem::drop(x);\n    assert!(y.is_unique());\n    let mut y = Arc::try_unique(y).expect(\"y is unique\");\n    *y += 73;\n    assert_eq!(*y.deref(), 80);\n    let y = y.shareable();\n    assert!(y.is_unique());\n    assert_eq!(*y.deref(), 80);\n\n    let yb = y.borrow_arc();\n    assert_eq!(*yb.deref(), 80);\n    assert_eq!(ArcBorrow::count(yb, Ordering::Relaxed), 1);\n    let yb2 = yb.clone();\n    assert_eq!(ArcBorrow::count(yb, Ordering::Relaxed), 1);\n    assert_eq!(ArcBorrow::count(yb2, Ordering::Relaxed), 1);\n    let ybr = ArcBorrow::as_arc(\u0026yb2);\n    assert_eq!(Arc::count(ybr, Ordering::Relaxed), 1);\n    assert!(ybr.is_unique());\n}","traces":[{"line":6,"address":[4214357,4214352],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":7,"address":[4218023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4218156,4218106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4218308,4218141,4218185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[4218290,4218676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4218700,4218751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4218787,4218834,4218737],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4218795,4219020,4218871],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[4218978,4219397,4219546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4219504,4219915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4219997,4220048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4220192,4220034,4220084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4220228,4220100,4220260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4220620,4220242,4220743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4220717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4221111,4221177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4221206,4221138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4221288,4225396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4221506,4221360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4221472,4221874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4221890,4221960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4221945,4222112,4221989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4222094,4222480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4222496,4222650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[4223151,4222608,4223018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4223133,4223528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4223536,4223732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[4224109,4224242,4223690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4224224,4224601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[4224609,4224768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[4225108,4225087,4224754],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":31,"coverable":31},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","tests","dst_tests.rs"],"content":"use elysees::*;\nuse slice_dst::SliceWithHeader;\nuse erasable::Thin;\nuse std::iter::FromIterator;\n\n#[test]\nfn basic_dst_test() {\n    let vec = Vec::from_iter(0..100);\n    let arc: Arc\u003c_\u003e = SliceWithHeader::new(\"header\", 0..100);\n    assert_eq!(\n        std::mem::size_of_val(\u0026arc),\n        2 * std::mem::size_of::\u003cusize\u003e()\n    );\n    assert_eq!(arc.header, \"header\");\n    assert_eq!(arc.slice, vec[..]);\n    assert!(arc.is_unique());\n    let thin: Thin\u003c_\u003e = arc.into();\n    assert_eq!(thin.header, \"header\");\n    assert_eq!(thin.slice, vec[..]);\n    assert_eq!(\n        std::mem::size_of_val(\u0026thin),\n        std::mem::size_of::\u003cusize\u003e()\n    )\n}\n","traces":[{"line":7,"address":[4228128,4228194],"length":1,"stats":{"Line":3},"fn_name":"basic_dst_test"},{"line":8,"address":[4228135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4228209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4228560,4228435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4228328,4228369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4232007,4228413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4228937,4228542,4229083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4229057,4229468,4229747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4229730,4230146,4230191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4230152,4230228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4230391,4230244,4230431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4230405,4231096,4230816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4231474,4231585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4231078,4231466],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14}]};
        var previousData = {"files":[{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","arc.rs"],"content":"use crate::{abort, ArcBorrow, ArcBox};\nuse alloc::alloc::{alloc, dealloc, Layout};\nuse core::borrow::Borrow;\nuse core::cmp::Ordering;\nuse core::convert::From;\nuse core::fmt;\nuse core::hash::{Hash, Hasher};\nuse core::marker::PhantomData;\nuse core::mem;\nuse core::ops::Deref;\nuse core::ptr;\nuse core::sync::atomic;\nuse core::sync::atomic::Ordering::{self as LoadOrdering, Acquire, Relaxed, Release};\nuse core::{isize, usize};\n#[cfg(feature = \"erasable\")]\nuse erasable::{Erasable, ErasablePtr, ErasedPtr};\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Serialize};\n#[cfg(feature = \"slice-dst\")]\nuse slice_dst::{AllocSliceDst, SliceDst, TryAllocSliceDst};\n#[cfg(feature = \"stable_deref_trait\")]\nuse stable_deref_trait::{CloneStableDeref, StableDeref};\n\n/// A soft limit on the amount of references that may be made to an `Arc`.\n///\n/// Going above this limit will abort your program (although not\n/// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\nconst MAX_REFCOUNT: usize = (isize::MAX) as usize;\n\n/// The object allocated by an Arc\u003cT\u003e\n#[repr(C)]\npub struct ArcInner\u003cT: ?Sized\u003e {\n    pub(crate) count: atomic::AtomicUsize,\n    pub(crate) data: T,\n}\n\nimpl\u003cT: ?Sized\u003e ArcInner\u003cT\u003e {\n    /// Get the theoretical offset of a piece of data in an `ArcInner`, as well as the layout of that `ArcInner`\n    #[inline]\n    pub fn data_offset(data: \u0026T) -\u003e (Layout, usize) {\n        let atomic_layout = Layout::new::\u003catomic::AtomicUsize\u003e();\n        atomic_layout\n            .extend(Layout::for_value(data))\n            .unwrap_or_else(|_| abort())\n    }\n    /// Get an untyped pointer to the inner data from a data pointer, along with a layout\n    #[inline]\n    pub(crate) unsafe fn inner_ptr\u003c'a\u003e(ptr: *const T) -\u003e (Layout, *const u8) {\n        let (layout, data_offset) = ArcInner::data_offset(\u0026*ptr);\n        (layout, (ptr as *const u8).sub(data_offset))\n    }\n    /// Get an untyped mutable pointer to the inner data from a data pointer, along with a layout\n    #[inline]\n    pub(crate) unsafe fn inner_ptr_mut\u003c'a\u003e(ptr: *mut T) -\u003e (Layout, *mut u8) {\n        let (layout, data_offset) = ArcInner::data_offset(\u0026*ptr);\n        (layout, (ptr as *mut u8).sub(data_offset))\n    }\n    /// Get a reference to the reference count from a data pointer\n    #[inline]\n    pub(crate) unsafe fn refcount_ptr\u003c'a\u003e(ptr: *const T) -\u003e \u0026'a atomic::AtomicUsize {\n        \u0026*(ArcInner::inner_ptr(ptr).1 as *const atomic::AtomicUsize)\n    }\n}\n\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Send for ArcInner\u003cT\u003e {}\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Sync for ArcInner\u003cT\u003e {}\n\n/// An atomically reference counted shared pointer\n///\n/// See the documentation for [`Arc`] in the standard library.\n/// Unlike the standard library `Arc`, this `Arc` holds a pointer to the `T` instead of to the entire `ArcInner`.\n/// This makes the struct FFI-compatible, and allows a variety of pointer casts, e.g. `\u0026[Arc\u003cT\u003e]` to `\u0026[\u0026T]`.\n///\n/// ```text\n///   std::sync::Arc\u003cT\u003e     elysees::Arc\u003cT\u003e\n///   |                     |\n///   v                     v\n///  --------------------------------------\n/// | RefCount            | T (data)       | [ArcInner\u003cT\u003e]\n///  --------------------------------------\n/// ```\n///\n/// This means that this is a direct pointer to its contained data (and can be read from by both C/C++ and Rust)\n///\n/// This is very useful if you have an Arc-containing struct shared between Rust and C/C++,\n/// and wish for C/C++ to be able to read the data behind the `Arc` without incurring\n/// an FFI call overhead. This also enables a variety of useful casts, which are provided as safe functions by\n/// the library, e.g. \u0026Arc\u003cT\u003e -\u003e \u0026*const T, which can help with safe implementation of complex `ByAddress`\n/// datastructures\n///\n/// [`Arc`]: https://doc.rust-lang.org/stable/std/sync/struct.Arc.html\n#[repr(transparent)]\npub struct Arc\u003cT: ?Sized\u003e {\n    pub(crate) ptr: ptr::NonNull\u003cT\u003e,\n    pub(crate) phantom: PhantomData\u003cT\u003e,\n}\n\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Send for Arc\u003cT\u003e {}\nunsafe impl\u003cT: ?Sized + Sync + Send\u003e Sync for Arc\u003cT\u003e {}\n\nimpl\u003cT\u003e Arc\u003cT\u003e {\n    /// Construct an `Arc\u003cT\u003e`\n    #[inline]\n    pub fn new(data: T) -\u003e Self {\n        let inner = ArcInner {\n            count: atomic::AtomicUsize::new(1),\n            data,\n        };\n        let layout = Layout::for_value(\u0026inner);\n        let alloc_ref = unsafe {\n            let allocation = alloc(layout) as *mut ArcInner\u003cT\u003e;\n            ptr::write(allocation, inner);\n            \u0026*allocation\n        };\n        Arc {\n            ptr: (\u0026alloc_ref.data).into(),\n            phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Arc\u003cT\u003e {\n    /// Borrow this `Arc\u003cT\u003e` as an `ArcBorrow\u003cT\u003e`\n    #[inline]\n    pub fn borrow_arc(\u0026self) -\u003e ArcBorrow\u003cT\u003e {\n        unsafe { ArcBorrow::from_ref(self.deref()) }\n    }\n    /// Leak this `Arc\u003cT\u003e`, getting an `ArcBorrow\u003c'static, T\u003e`\n    ///\n    /// You can call the `get` method on the returned `ArcBorrow` to get an `\u0026'static T`.\n    /// Note that using this can (obviously) cause memory leaks!\n    #[inline]\n    pub fn leak(this: Arc\u003cT\u003e) -\u003e ArcBorrow\u003c'static, T\u003e {\n        let result = unsafe { ArcBorrow::from_ref(\u0026*this.ptr.as_ptr()) };\n        mem::forget(this);\n        result\n    }\n    /// Convert the `Arc\u003cT\u003e` to a raw pointer, suitable for use across FFI\n    ///\n    /// Note: This returns a pointer to the data T, which is offset in the allocation.\n    #[inline]\n    pub fn into_raw(this: Self) -\u003e *const T {\n        let ptr = this.ptr;\n        mem::forget(this);\n        ptr.as_ptr()\n    }\n    /// Get the raw pointer underlying this `Arc\u003cT\u003e`\n    #[inline]\n    pub fn as_ptr(this: \u0026Arc\u003cT\u003e) -\u003e *const T {\n        this.ptr.as_ptr()\n    }\n    /// Convert the `Arc\u003cT\u003e` from a raw pointer obtained from `into_raw()`\n    ///\n    /// Note: This raw pointer will be offset in the allocation and must be preceded\n    /// by the atomic count.\n    #[inline]\n    pub unsafe fn from_raw(ptr: *const T) -\u003e Arc\u003cT\u003e {\n        Arc {\n            ptr: ptr::NonNull::new_unchecked(ptr as *mut T),\n            phantom: PhantomData,\n        }\n    }\n    // Non-inlined part of `drop`. Just invokes the destructor.\n    #[inline(never)]\n    unsafe fn drop_slow(\u0026mut self) {\n        // Step 1: drop data\n        ptr::drop_in_place(self.ptr.as_ptr());\n        // Step 2: free Inner\n        let (layout, data) = ArcInner::inner_ptr_mut(self.ptr.as_ptr());\n        dealloc(data, layout)\n    }\n    /// Get a reference to the reference count of this `Arc`\n    #[inline]\n    fn borrow_refcount(\u0026self) -\u003e \u0026atomic::AtomicUsize {\n        unsafe { ArcInner::refcount_ptr(self.ptr.as_ptr()) }\n    }\n    /// Whether or not the `Arc` is uniquely owned (is the refcount 1?).\n    #[inline]\n    pub fn is_unique(\u0026self) -\u003e bool {\n        // See the extensive discussion in [1] for why this needs to be Acquire.\n        //\n        // [1] https://github.com/servo/servo/issues/21186\n        Arc::count(self, Acquire) == 1\n    }\n    /// Try to convert this `Arc` to an `ArcBox` if it is unique\n    #[inline]\n    pub fn try_unique(self) -\u003e Result\u003cArcBox\u003cT\u003e, Arc\u003cT\u003e\u003e {\n        if self.is_unique() {\n            Ok(ArcBox(self))\n        } else {\n            Err(self)\n        }\n    }\n    /// Get the reference count of this `Arc` with a given ordering\n    #[inline]\n    pub fn count(this: \u0026Arc\u003cT\u003e, ordering: LoadOrdering) -\u003e usize {\n        this.borrow_refcount().load(ordering)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Drop for Arc\u003cT\u003e {\n    #[inline]\n    fn drop(\u0026mut self) {\n        // Because `fetch_sub` is already atomic, we do not need to synchronize\n        // with other threads unless we are going to delete the object.\n        if self.borrow_refcount().fetch_sub(1, Release) != 1 {\n            return;\n        }\n\n        // FIXME(bholley): Use the updated comment when [2] is merged.\n        //\n        // This load is needed to prevent reordering of use of the data and\n        // deletion of the data.  Because it is marked `Release`, the decreasing\n        // of the reference count synchronizes with this `Acquire` load. This\n        // means that use of the data happens before decreasing the reference\n        // count, which happens before this load, which happens before the\n        // deletion of the data.\n        //\n        // As explained in the [Boost documentation][1],\n        //\n        // \u003e It is important to enforce any possible access to the object in one\n        // \u003e thread (through an existing reference) to *happen before* deleting\n        // \u003e the object in a different thread. This is achieved by a \"release\"\n        // \u003e operation after dropping a reference (any access to the object\n        // \u003e through this reference must obviously happened before), and an\n        // \u003e \"acquire\" operation before deleting the object.\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        // [2]: https://github.com/rust-lang/rust/pull/41714\n        self.borrow_refcount().load(Acquire);\n\n        unsafe {\n            self.drop_slow();\n        }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Clone for Arc\u003cT\u003e {\n    #[inline]\n    fn clone(\u0026self) -\u003e Self {\n        // Using a relaxed ordering is alright here, as knowledge of the\n        // original reference prevents other threads from erroneously deleting\n        // the object.\n        //\n        // As explained in the [Boost documentation][1], Increasing the\n        // reference counter can always be done with memory_order_relaxed: New\n        // references to an object can only be formed from an existing\n        // reference, and passing an existing reference from one thread to\n        // another must already provide any required synchronization.\n        //\n        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n        let old_size = self.borrow_refcount().fetch_add(1, Relaxed);\n\n        // However we need to guard against massive refcounts in case someone\n        // is `mem::forget`ing Arcs. If we don't do this the count can overflow\n        // and users will use-after free. We racily saturate to `isize::MAX` on\n        // the assumption that there aren't ~2 billion threads incrementing\n        // the reference count at once. This branch will never be taken in\n        // any realistic program.\n        //\n        // We abort because such a program is incredibly degenerate, and we\n        // don't care to support it.\n        if old_size \u003e MAX_REFCOUNT {\n            abort();\n        }\n\n        Arc {\n            ptr: self.ptr,\n            phantom: PhantomData,\n        }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Deref for Arc\u003cT\u003e {\n    type Target = T;\n\n    #[inline]\n    fn deref(\u0026self) -\u003e \u0026T {\n        unsafe { \u0026*self.ptr.as_ptr() }\n    }\n}\n\nimpl\u003cT: Clone\u003e Arc\u003cT\u003e {\n    /// Makes a mutable reference to the `ArcHandle`, cloning if necessary\n    ///\n    /// This is functionally equivalent to [`Arc::make_mut`][mm] from the standard library.\n    ///\n    /// If this `ArcHandle` is uniquely owned, `make_mut()` will provide a mutable\n    /// reference to the contents. If not, `make_mut()` will create a _new_ `ArcHandle`\n    /// with a copy of the contents, update `this` to point to it, and provide\n    /// a mutable reference to its contents.\n    ///\n    /// This is useful for implementing copy-on-write schemes where you wish to\n    /// avoid copying things if your `Arc` is not shared.\n    ///\n    /// [mm]: https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.make_mut\n    #[inline]\n    pub fn make_mut(this: \u0026mut Self) -\u003e \u0026mut T {\n        if !this.is_unique() {\n            // Another pointer exists; clone\n            *this = Arc::new((**this).clone());\n        }\n\n        unsafe {\n            // This unsafety is ok because we're guaranteed that the pointer\n            // returned is the *only* pointer that will ever be returned to T. Our\n            // reference count is guaranteed to be 1 at this point, and we required\n            // the Arc itself to be `mut`, so we're returning the only possible\n            // reference to the inner data.\n            \u0026mut *this.ptr.as_ptr()\n        }\n    }\n    /// Convert this `Arc` to an `ArcBox`, cloning the internal data if necessary for uniqueness\n    #[inline]\n    pub fn unique(self) -\u003e ArcBox\u003cT\u003e {\n        if self.is_unique() {\n            ArcBox(self)\n        } else {\n            ArcBox::new(self.deref().clone())\n        }\n    }\n}\n\nimpl\u003cT: ?Sized + PartialEq\u003e PartialEq for Arc\u003cT\u003e {\n    fn eq(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) == *(*other)\n    }\n\n    fn ne(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) != *(*other)\n    }\n}\n\nimpl\u003cT: ?Sized + PartialOrd\u003e PartialOrd for Arc\u003cT\u003e {\n    fn partial_cmp(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e Option\u003cOrdering\u003e {\n        (**self).partial_cmp(\u0026**other)\n    }\n\n    fn lt(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003c *(*other)\n    }\n\n    fn le(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003c= *(*other)\n    }\n\n    fn gt(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003e *(*other)\n    }\n\n    fn ge(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e bool {\n        *(*self) \u003e= *(*other)\n    }\n}\n\nimpl\u003cT: ?Sized + Ord\u003e Ord for Arc\u003cT\u003e {\n    fn cmp(\u0026self, other: \u0026Arc\u003cT\u003e) -\u003e Ordering {\n        (**self).cmp(\u0026**other)\n    }\n}\n\nimpl\u003cT: ?Sized + Eq\u003e Eq for Arc\u003cT\u003e {}\n\nimpl\u003cT: ?Sized + fmt::Display\u003e fmt::Display for Arc\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\u0026**self, f)\n    }\n}\n\nimpl\u003cT: ?Sized + fmt::Debug\u003e fmt::Debug for Arc\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Debug::fmt(\u0026**self, f)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e fmt::Pointer for Arc\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Pointer::fmt(\u0026Arc::as_ptr(self), f)\n    }\n}\n\nimpl\u003cT: Default\u003e Default for Arc\u003cT\u003e {\n    #[inline]\n    fn default() -\u003e Arc\u003cT\u003e {\n        Arc::new(Default::default())\n    }\n}\n\nimpl\u003cT: ?Sized + Hash\u003e Hash for Arc\u003cT\u003e {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        (**self).hash(state)\n    }\n}\n\nimpl\u003cT\u003e From\u003cT\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn from(t: T) -\u003e Self {\n        Arc::new(t)\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cT\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cT\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*const T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*const T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*mut T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*mut T\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cptr::NonNull\u003cT\u003e\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cptr::NonNull\u003cT\u003e\u003e for Arc\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003cT: ?Sized\u003e StableDeref for Arc\u003cT\u003e {}\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003cT: ?Sized\u003e CloneStableDeref for Arc\u003cT\u003e {}\n\n#[cfg(feature = \"serde\")]\nimpl\u003c'de, T: Deserialize\u003c'de\u003e\u003e Deserialize\u003c'de\u003e for Arc\u003cT\u003e {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cArc\u003cT\u003e, D::Error\u003e\n    where\n        D: ::serde::de::Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(Arc::new)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl\u003cT: ?Sized + Serialize\u003e Serialize for Arc\u003cT\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ::serde::ser::Serializer,\n    {\n        (**self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"erasable\")]\nunsafe impl\u003cT: ?Sized + Erasable\u003e ErasablePtr for Arc\u003cT\u003e {\n    fn erase(this: Self) -\u003e ErasedPtr {\n        let ptr = unsafe { ptr::NonNull::new_unchecked(Arc::into_raw(this) as *mut _) };\n        T::erase(ptr)\n    }\n\n    unsafe fn unerase(this: ErasedPtr) -\u003e Self {\n        Self::from_raw(T::unerase(this).as_ptr())\n    }\n}\n\n#[cfg(feature = \"slice-dst\")]\nunsafe impl\u003cS: ?Sized + SliceDst\u003e TryAllocSliceDst\u003cS\u003e for Arc\u003cS\u003e {\n    unsafe fn try_new_slice_dst\u003cI, E\u003e(len: usize, init: I) -\u003e Result\u003cSelf, E\u003e\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e) -\u003e Result\u003c(), E\u003e,\n    {\n        pub struct RawAlloc(*mut u8, Layout);\n\n        impl Drop for RawAlloc {\n            fn drop(\u0026mut self) {\n                unsafe { dealloc(self.0, self.1) }\n            }\n        }\n\n        // Compute layouts\n        let slice_layout = S::layout_for(len);\n        let count_layout = Layout::new::\u003catomic::AtomicUsize\u003e();\n        let (inner_layout, slice_offset) = count_layout\n            .extend(slice_layout)\n            .expect(\"Integer overflow computing slice layout\");\n        // Allocate\n        let inner_alloc = alloc(inner_layout);\n        let drop_guard = RawAlloc(inner_alloc, inner_layout);\n        // Write counter\n        ptr::write(\n            inner_alloc as *mut atomic::AtomicUsize,\n            atomic::AtomicUsize::new(1),\n        );\n\n        // Get slice pointer\n        let slice_addr = inner_alloc.add(slice_offset) as *mut ();\n        let slice_ptr = core::slice::from_raw_parts_mut(slice_addr, len);\n\n        // Get DST pointer\n        let ptr = S::retype(ptr::NonNull::new_unchecked(slice_ptr));\n\n        // Attempt to initialize the DST pointer\n        init(ptr)?;\n\n        // Successful construction: forget the drop guard and make an `Arc`\n        mem::forget(drop_guard);\n        Ok(Arc {\n            ptr,\n            phantom: PhantomData,\n        })\n    }\n}\n\nunsafe impl\u003cS: ?Sized + SliceDst\u003e AllocSliceDst\u003cS\u003e for Arc\u003cS\u003e {\n    unsafe fn new_slice_dst\u003cI\u003e(len: usize, init: I) -\u003e Self\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e),\n    {\n        enum Void {} // or never (!) once it is stable\n        #[allow(clippy::unit_arg)]\n        let init = |ptr| Ok::\u003c(), Void\u003e(init(ptr));\n        match Self::try_new_slice_dst(len, init) {\n            Ok(a) =\u003e a,\n            Err(void) =\u003e match void {},\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn data_offset_sanity_tests() {\n        #[allow(dead_code)]\n        struct MyStruct {\n            id: usize,\n            name: String,\n            hash: u64,\n        };\n        let inner = ArcInner {\n            count: atomic::AtomicUsize::new(1),\n            data: MyStruct {\n                id: 596843,\n                name: \"Jane\".into(),\n                hash: 0xFF45345,\n            },\n        };\n        let data = \u0026inner.data;\n        let data_ptr = data as *const _;\n        let data_addr = data_ptr as usize;\n        let inner_addr = \u0026inner as *const _ as usize;\n        let (layout, data_offset) = ArcInner::data_offset(data);\n        assert_eq!(data_addr - inner_addr, data_offset);\n        assert_eq!(layout, Layout::for_value(\u0026inner));\n    }\n}\n","traces":[{"line":40,"address":[4225408],"length":1,"stats":{"Line":3},"fn_name":"data_offset\u003celysees::arc::tests::data_offset_sanity_tests::MyStruct\u003e"},{"line":41,"address":[4225435],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[4225470],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[4225455],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[4225539,4225524,4225520],"length":1,"stats":{"Line":0},"fn_name":"{{closure}}\u003celysees::arc::tests::data_offset_sanity_tests::MyStruct\u003e"},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[4251918,4251840],"length":1,"stats":{"Line":1},"fn_name":"try_new_slice_dst\u003cslice_dst::provided_types::SliceWithHeader\u003c\u0026str, i32\u003e,closure-0,elysees::arc::{{impl}}::new_slice_dst::Void\u003e"},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[4216944],"length":1,"stats":{"Line":0},"fn_name":"drop"},{"line":505,"address":[4216949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[4251648],"length":1,"stats":{"Line":1},"fn_name":"new_slice_dst\u003cslice_dst::provided_types::SliceWithHeader\u003c\u0026str, i32\u003e,closure-0\u003e"},{"line":550,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":562,"address":[4226064,4226107],"length":1,"stats":{"Line":3},"fn_name":"data_offset_sanity_tests"},{"line":570,"address":[4226071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[4226150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[4226278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":578,"address":[4226286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":579,"address":[4226294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":580,"address":[4226310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":581,"address":[4226326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":582,"address":[4227425,4226467,4226609,4226416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":583,"address":[4226583,4226956,4227096],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":83,"coverable":153},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","borrow.rs"],"content":"use core::borrow::Borrow;\nuse core::convert::AsRef;\nuse core::hash::Hash;\nuse core::mem;\nuse core::ops::Deref;\nuse core::ptr;\nuse core::sync::atomic::Ordering;\n#[cfg(feature = \"erasable\")]\nuse erasable::{Erasable, ErasablePtr, ErasedPtr};\n#[cfg(feature = \"serde\")]\nuse serde::Serialize;\n#[cfg(feature = \"stable_deref_trait\")]\nuse stable_deref_trait::{CloneStableDeref, StableDeref};\n\nuse super::Arc;\n\n/// A \"borrowed `Arc`\". This is a pointer to\n/// a T that is known to have been allocated within an\n/// `Arc`.\n///\n/// This is equivalent in guarantees to `\u0026ArcHandle\u003cT\u003e`, however it is\n/// a bit more flexible. To obtain an `\u0026ArcHandle\u003cT\u003e` you must have\n/// an `ArcHandle\u003cT\u003e` instance somewhere pinned down until we're done with it.\n/// It's also a direct pointer to `T`, so using this involves less pointer-chasing\n///\n/// However, C++ code may hand us refcounted things as pointers to T directly,\n/// so we have to conjure up a temporary `Arc` on the stack each time. The\n/// same happens for when the object is managed by a `Arc`.\n///\n/// `ArcBorrow` lets us deal with borrows of known-refcounted objects\n/// without needing to worry about where the `Arc\u003cT\u003e` is.\n#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[repr(transparent)]\npub struct ArcBorrow\u003c'a, T: ?Sized + 'a\u003e(pub(crate) \u0026'a T);\n\nimpl\u003c'a, T: ?Sized\u003e Copy for ArcBorrow\u003c'a, T\u003e {}\nimpl\u003c'a, T: ?Sized\u003e Clone for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn clone(\u0026self) -\u003e Self {\n        *self\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e ArcBorrow\u003c'a, T\u003e {\n    /// Clone this as an `Arc\u003cT\u003e`. This bumps the refcount.\n    #[inline]\n    pub fn clone_arc(\u0026self) -\u003e Arc\u003cT\u003e {\n        self.as_arc().clone()\n    }\n\n    /// Borrow this as an `Arc\u003cT\u003e`. This does *not* bump the refcount.\n    #[inline]\n    pub fn as_arc(\u0026self) -\u003e \u0026Arc\u003cT\u003e {\n        unsafe { std::mem::transmute(self) }\n    }\n\n    /// For constructing from a reference known to be Arc-backed,\n    /// e.g. if we obtain such a reference over FFI\n    #[inline]\n    pub unsafe fn from_ref(r: \u0026'a T) -\u003e Self {\n        ArcBorrow(r)\n    }\n\n    /// Compare two `ArcBorrow`s via pointer equality. Will only return\n    /// true if they come from the same allocation\n    #[inline]\n    pub fn ptr_eq(this: \u0026Self, other: \u0026Self) -\u003e bool {\n        this.0 as *const T == other.0 as *const T\n    }\n\n    /// Similar to deref, but uses the lifetime |a| rather than the lifetime of\n    /// self, which is incompatible with the signature of the Deref trait.\n    #[inline]\n    pub fn get(\u0026self) -\u003e \u0026'a T {\n        self.0\n    }\n\n    /// Get the reference count of this `Arc` with a given memory ordering\n    pub fn count(this: ArcBorrow\u003c'a, T\u003e, ordering: Ordering) -\u003e usize {\n        Arc::count(this.as_arc(), ordering)\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Deref for ArcBorrow\u003c'a, T\u003e {\n    type Target = T;\n\n    #[inline]\n    fn deref(\u0026self) -\u003e \u0026T {\n        self.0\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003cArc\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn borrow(\u0026self) -\u003e \u0026Arc\u003cT\u003e {\n        self.as_arc()\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003c\u0026'a T\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn borrow(\u0026self) -\u003e \u0026\u0026'a T {\n        unsafe { std::mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003cT\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn borrow(\u0026self) -\u003e \u0026T {\n        self.deref()\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003cArc\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026Arc\u003cT\u003e {\n        self.as_arc()\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003c\u0026'a T\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026\u0026'a T {\n        unsafe { std::mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003cT\u003e for ArcBorrow\u003c'a, T\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026T {\n        self.deref()\n    }\n}\n\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003c*const T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003c*const T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003c*mut T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003c*mut T\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e Borrow\u003cptr::NonNull\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003c'a, T: ?Sized\u003e AsRef\u003cptr::NonNull\u003cT\u003e\u003e for ArcBorrow\u003c'a, T\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003c'a, T: ?Sized\u003e StableDeref for ArcBorrow\u003c'a, T\u003e {}\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003c'a, T: ?Sized\u003e CloneStableDeref for ArcBorrow\u003c'a, T\u003e {}\n\n#[cfg(feature = \"serde\")]\nimpl\u003c'a, T: ?Sized + Serialize\u003e Serialize for ArcBorrow\u003c'a, T\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ::serde::ser::Serializer,\n    {\n        (**self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"erasable\")]\nunsafe impl\u003c'a, T: ?Sized + Erasable\u003e ErasablePtr for ArcBorrow\u003c'a, T\u003e {\n    fn erase(this: Self) -\u003e ErasedPtr {\n        T::erase(this.0.into())\n    }\n    unsafe fn unerase(this: ErasedPtr) -\u003e Self {\n        ArcBorrow(\u0026*T::unerase(this).as_ptr())\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":45},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","lib.rs"],"content":"// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n// file at the top-level directory of this distribution and at\n// http://rust-lang.org/COPYRIGHT.\n//\n// Licensed under the Apache License, Version 2.0 \u003cLICENSE-APACHE or\n// http://www.apache.org/licenses/LICENSE-2.0\u003e or the MIT license\n// \u003cLICENSE-MIT or http://opensource.org/licenses/MIT\u003e, at your\n// option. This file may not be copied, modified, or distributed\n// except according to those terms.\n\n//! [![crates.io](https://img.shields.io/crates/v/elysees)](https://crates.io/crates/elysees)\n//! [![Downloads](https://img.shields.io/crates/d/elysees)](https://crates.io/crates/elysees)\n//! Fork of Arc, now with more pointer tricks.\n\n#![allow(missing_docs)]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nextern crate alloc;\n#[cfg(feature = \"std\")]\nextern crate core;\n\n#[cfg(feature = \"serde\")]\nextern crate serde;\n#[cfg(feature = \"stable_deref_trait\")]\nextern crate stable_deref_trait;\n\nmod arc;\nmod borrow;\n#[cfg(feature = \"ptr-union\")]\nmod union;\nmod unique;\n\npub use arc::*;\npub use borrow::*;\npub use union::*;\npub use unique::*;\n\n#[cfg(feature = \"std\")]\nuse std::process::abort;\n\n// `no_std`-compatible abort by forcing a panic while already panicing.\n#[cfg(not(feature = \"std\"))]\n#[cold]\nfn abort() -\u003e ! {\n    struct PanicOnDrop;\n    impl Drop for PanicOnDrop {\n        fn drop(\u0026mut self) {\n            panic!()\n        }\n    }\n    let _double_panicer = PanicOnDrop;\n    panic!();\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","union.rs"],"content":"use crate::{Arc, ArcBorrow, ArcBox};\nuse erasable::ErasablePtr;\nuse erasable::Thin;\nuse ptr_union::{Builder2, Builder4, Union2, Union4};\n\n/// A value which can be made into *any* pointer union\npub unsafe trait UnionAlign: Sized + ErasablePtr {\n    fn left\u003cB: UnionAlign\u003e(this: Self) -\u003e Union2\u003cSelf, B\u003e {\n        unsafe { Builder2::new_unchecked().a(this) }\n    }\n    fn right\u003cA: UnionAlign\u003e(this: Self) -\u003e Union2\u003cA, Self\u003e {\n        unsafe { Builder2::new_unchecked().b(this) }\n    }\n    fn a\u003cB: UnionAlign, C: UnionAlign, D: UnionAlign\u003e(this: Self) -\u003e Union4\u003cSelf, B, C, D\u003e {\n        unsafe { Builder4::new_unchecked().a(this) }\n    }\n    fn b\u003cA: UnionAlign, C: UnionAlign, D: UnionAlign\u003e(this: Self) -\u003e Union4\u003cA, Self, C, D\u003e {\n        unsafe { Builder4::new_unchecked().b(this) }\n    }\n    fn c\u003cA: UnionAlign, B: UnionAlign, D: UnionAlign\u003e(this: Self) -\u003e Union4\u003cA, B, Self, D\u003e {\n        unsafe { Builder4::new_unchecked().c(this) }\n    }\n    fn d\u003cA: UnionAlign, B: UnionAlign, C: UnionAlign\u003e(this: Self) -\u003e Union4\u003cA, B, C, Self\u003e {\n        unsafe { Builder4::new_unchecked().d(this) }\n    }\n}\n\nunsafe impl\u003cT: ?Sized\u003e UnionAlign for Arc\u003cT\u003e where Arc\u003cT\u003e: ErasablePtr {}\nunsafe impl\u003cT: ?Sized\u003e UnionAlign for Thin\u003cArc\u003cT\u003e\u003e\nwhere\n    Thin\u003cArc\u003cT\u003e\u003e: ErasablePtr,\n    Arc\u003cT\u003e: ErasablePtr,\n{\n}\nunsafe impl\u003c'a, T: ?Sized\u003e UnionAlign for ArcBorrow\u003c'a, T\u003e where ArcBorrow\u003c'a, T\u003e: ErasablePtr {}\nunsafe impl\u003cT: ?Sized\u003e UnionAlign for ArcBox\u003cT\u003e where ArcBox\u003cT\u003e: ErasablePtr {}","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","src","unique.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\nuse core::convert::AsRef;\nuse core::hash::Hash;\nuse core::mem;\nuse core::ops::{Deref, DerefMut};\nuse core::ptr;\n#[cfg(feature = \"erasable\")]\nuse erasable::{Erasable, ErasablePtr, ErasedPtr};\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Serialize};\n#[cfg(feature = \"slice-dst\")]\nuse slice_dst::{AllocSliceDst, SliceDst, TryAllocSliceDst};\n#[cfg(feature = \"stable_deref_trait\")]\nuse stable_deref_trait::StableDeref;\n\nuse super::Arc;\n\n/// An `Arc` that is known to be uniquely owned\n///\n/// When `Arc`s are constructed, they are known to be\n/// uniquely owned. In such a case it is safe to mutate\n/// the contents of the `Arc`. Normally, one would just handle\n/// this by mutating the data on the stack before allocating the\n/// `Arc`, however it's possible the data is large or unsized\n/// and you need to heap-allocate it earlier in such a way\n/// that it can be freely converted into a regular `Arc` once you're\n/// done.\n///\n/// `ArcBox` exists for this purpose, when constructed it performs\n/// the same allocations necessary for an `Arc`, however it allows mutable access.\n/// Once the mutation is finished, you can call `.shareable()` and get a regular `Arc`\n/// out of it. You can also attempt to cast an `Arc` back into a `ArcBox`, which will\n/// succeed if the `Arc` is unique\n///\n/// ```rust\n/// # use elysees::ArcBox;\n/// # use std::ops::Deref;\n/// let data = [1, 2, 3, 4, 5];\n/// let mut x = ArcBox::new(data);\n/// let x_ptr = x.deref() as *const _;\n///\n/// x[4] = 7; // mutate!\n///\n/// // The allocation has been modified, but not moved\n/// assert_eq!(x.deref(), \u0026[1, 2, 3, 4, 7]);\n/// assert_eq!(x_ptr, x.deref() as *const _);\n///\n/// let y = x.shareable(); // y is an Arc\u003cT\u003e\n///\n/// // The allocation has not been modified or moved\n/// assert_eq!(y.deref(), \u0026[1, 2, 3, 4, 7]);\n/// assert_eq!(x_ptr, y.deref() as *const _);\n/// ```\n\n#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n#[repr(transparent)]\npub struct ArcBox\u003cT: ?Sized\u003e(pub(crate) Arc\u003cT\u003e);\n\nimpl\u003cT\u003e ArcBox\u003cT\u003e {\n    /// Construct a new ArcBox\n    #[inline]\n    pub fn new(data: T) -\u003e Self {\n        ArcBox(Arc::new(data))\n    }\n}\n\nimpl\u003cT: Clone\u003e Clone for ArcBox\u003cT\u003e {\n    #[inline]\n    fn clone(\u0026self) -\u003e ArcBox\u003cT\u003e {\n        ArcBox(Arc::new(self.0.deref().clone()))\n    }\n}\n\nimpl\u003cT: ?Sized\u003e ArcBox\u003cT\u003e {\n    /// Convert to a shareable Arc\u003cT\u003e once we're done mutating it\n    #[inline]\n    pub fn shareable(self) -\u003e Arc\u003cT\u003e {\n        self.0\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Deref for ArcBox\u003cT\u003e {\n    type Target = T;\n    #[inline]\n    fn deref(\u0026self) -\u003e \u0026T {\n        \u0026*self.0\n    }\n}\n\nimpl\u003cT: ?Sized\u003e DerefMut for ArcBox\u003cT\u003e {\n    #[inline]\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut T {\n        // We know this to be uniquely owned\n        unsafe { \u0026mut *self.0.ptr.as_ptr() }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026T {\n        \u0026**self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e BorrowMut\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut **self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsMut\u003cT\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_mut(\u0026mut self) -\u003e \u0026mut T {\n        \u0026mut **self\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*const T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*const T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*const T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003c*mut T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003c*mut T\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026*mut T {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e Borrow\u003cptr::NonNull\u003cT\u003e\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn borrow(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\nimpl\u003cT: ?Sized\u003e AsRef\u003cptr::NonNull\u003cT\u003e\u003e for ArcBox\u003cT\u003e {\n    #[inline]\n    fn as_ref(\u0026self) -\u003e \u0026ptr::NonNull\u003cT\u003e {\n        unsafe { mem::transmute(self) }\n    }\n}\n\n#[cfg(feature = \"stable_deref_trait\")]\nunsafe impl\u003cT: ?Sized\u003e StableDeref for ArcBox\u003cT\u003e {}\n\n#[cfg(feature = \"serde\")]\nimpl\u003c'de, T: Deserialize\u003c'de\u003e\u003e Deserialize\u003c'de\u003e for ArcBox\u003cT\u003e {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e Result\u003cArcBox\u003cT\u003e, D::Error\u003e\n    where\n        D: ::serde::de::Deserializer\u003c'de\u003e,\n    {\n        T::deserialize(deserializer).map(ArcBox::new)\n    }\n}\n\n#[cfg(feature = \"serde\")]\nimpl\u003cT: ?Sized + Serialize\u003e Serialize for ArcBox\u003cT\u003e {\n    fn serialize\u003cS\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: ::serde::ser::Serializer,\n    {\n        (**self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"erasable\")]\nunsafe impl\u003cT: ?Sized + Erasable\u003e ErasablePtr for ArcBox\u003cT\u003e {\n    fn erase(this: Self) -\u003e ErasedPtr {\n        ErasablePtr::erase(this.0)\n    }\n\n    unsafe fn unerase(this: ErasedPtr) -\u003e Self {\n        ArcBox(ErasablePtr::unerase(this))\n    }\n}\n\n#[cfg(feature = \"slice-dst\")]\nunsafe impl\u003cS: ?Sized + SliceDst\u003e TryAllocSliceDst\u003cS\u003e for ArcBox\u003cS\u003e {\n    unsafe fn try_new_slice_dst\u003cI, E\u003e(len: usize, init: I) -\u003e Result\u003cSelf, E\u003e\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e) -\u003e Result\u003c(), E\u003e,\n    {\n        Arc::try_new_slice_dst(len, init).map(ArcBox)\n    }\n}\n\nunsafe impl\u003cS: ?Sized + SliceDst\u003e AllocSliceDst\u003cS\u003e for ArcBox\u003cS\u003e {\n    unsafe fn new_slice_dst\u003cI\u003e(len: usize, init: I) -\u003e Self\n    where\n        I: FnOnce(ptr::NonNull\u003cS\u003e),\n    {\n        ArcBox(Arc::new_slice_dst(len, init))\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[4217840],"length":1,"stats":{"Line":1},"fn_name":"shareable\u003ci32\u003e"},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4217808],"length":1,"stats":{"Line":1},"fn_name":"deref_mut\u003ci32\u003e"},{"line":94,"address":[4217817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":38},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","tests","arc_tests.rs"],"content":"use elysees::*;\nuse std::ops::Deref;\nuse std::sync::atomic::Ordering;\n\n#[test]\nfn basic_arc_creation_works() {\n    let x = Arc::new(7);\n    assert!(x.is_unique());\n    assert_eq!(*x.deref(), 7);\n    let y = x.clone();\n    assert!(!x.is_unique());\n    assert!(!y.is_unique());\n    assert_eq!(Arc::count(\u0026x, Ordering::Relaxed), 2);\n    assert_eq!(Arc::count(\u0026y, Ordering::Relaxed), 2);\n    let x = Arc::try_unique(x).expect_err(\"x is not unique!\");\n    assert!(!x.is_unique());\n    assert!(!y.is_unique());\n    assert_eq!(x, y);\n    assert_eq!(*x.deref(), 7);\n    std::mem::drop(x);\n    assert!(y.is_unique());\n    let mut y = Arc::try_unique(y).expect(\"y is unique\");\n    *y += 73;\n    assert_eq!(*y.deref(), 80);\n    let y = y.shareable();\n    assert!(y.is_unique());\n    assert_eq!(*y.deref(), 80);\n\n    let yb = y.borrow_arc();\n    assert_eq!(*yb.deref(), 80);\n    assert_eq!(ArcBorrow::count(yb, Ordering::Relaxed), 1);\n    let yb2 = yb.clone();\n    assert_eq!(ArcBorrow::count(yb, Ordering::Relaxed), 1);\n    assert_eq!(ArcBorrow::count(yb2, Ordering::Relaxed), 1);\n    let ybr = ArcBorrow::as_arc(\u0026yb2);\n    assert_eq!(Arc::count(ybr, Ordering::Relaxed), 1);\n    assert!(ybr.is_unique());\n}","traces":[{"line":6,"address":[4214357,4214352],"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":7,"address":[4217863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[4217946,4217996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4218148,4218025,4217981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[4218516,4218130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[4218591,4218540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[4218674,4218627,4218577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[4218635,4218711,4218860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[4219237,4219386,4218818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4219344,4219755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4219888,4219837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[4219924,4220032,4219874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4219940,4220068,4220100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4220583,4220460,4220082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4220557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4221017,4220951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[4221046,4220978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4222473,4221128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4221346,4221200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[4221696,4221312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[4221712,4221773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4221802,4221761,4221908],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","media","tekne","Storage","Documents","Projects","rain-lang","elysees","tests","dst_tests.rs"],"content":"use elysees::*;\nuse slice_dst::SliceWithHeader;\nuse erasable::Thin;\nuse std::iter::FromIterator;\n\n#[test]\nfn basic_dst_test() {\n    let vec = Vec::from_iter(0..100);\n    let arc: Arc\u003c_\u003e = SliceWithHeader::new(\"header\", 0..100);\n    assert_eq!(\n        std::mem::size_of_val(\u0026arc),\n        2 * std::mem::size_of::\u003cusize\u003e()\n    );\n    assert_eq!(arc.header, \"header\");\n    assert_eq!(arc.slice, vec[..]);\n    assert!(arc.is_unique());\n    let thin: Thin\u003c_\u003e = arc.into();\n    assert_eq!(thin.header, \"header\");\n    assert_eq!(thin.slice, vec[..]);\n    assert_eq!(\n        std::mem::size_of_val(\u0026thin),\n        std::mem::size_of::\u003cusize\u003e()\n    )\n}\n","traces":[{"line":7,"address":[4228128,4228194],"length":1,"stats":{"Line":3},"fn_name":"basic_dst_test"},{"line":8,"address":[4228135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[4228209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[4228435,4228560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[4228328,4228369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[4228413,4232007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[4228542,4228937,4229083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[4229468,4229747,4229057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[4230146,4229730,4230191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4230228,4230152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[4230431,4230244,4230391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4230816,4231096,4230405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4231474,4231585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4231466,4231078],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14}]};
    </script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>